/* ────────────────────────────  back/build.gradle  ──────────────────────────── */
import java.security.MessageDigest
import org.hidetake.groovy.ssh.session.SessionHandler          // плагин scp/ssh
import javax.xml.parsers.DocumentBuilderFactory

/***************************  ПЛАГИНЫ  *****************************************/
plugins {
    id 'java'
    id 'application'
    id 'org.springframework.boot' version '3.3.5'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'org.hidetake.ssh' version '2.10.1'             // «scp»‑цель
}

/***************************  ОБЩИЕ НАСТРОЙКИ  *********************************/
group   = 'org.awesoma'
version = '0.0.1-SNAPSHOT'

def MAIN_CLASS = 'org.awesoma.back.BackApplication'

application { mainClass = MAIN_CLASS }

java.toolchain.languageVersion = JavaLanguageVersion.of(17)
repositories      { mavenCentral() }
dependencies      { 
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'


    implementation 'io.jsonwebtoken:jjwt:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'


    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

/***************************  ПАРАМЕТРЫ ИЗ ФАЙЛА  *******************************/
def param = new Properties()
file("$rootDir/gradle/params.properties").withInputStream(param.&load)

/***************************  MANIFEST  *****************************************/
tasks.withType(Jar).configureEach {
    manifest.attributes(
        'Main-Class'           : MAIN_CLASS,
        'Implementation-Version': version
    )
}


/* compile */
tasks.register('compile') {
    group = 'build'; description = 'Compiles project sources'
    dependsOn 'classes'
}

/* build ─ всё как обычно, но явно зависит от compile */
tasks.named('build') { dependsOn 'compile' }

/* clean ─ стандартный, ничего менять не нужно */

/* test ─ сначала build, затем юнит‑тесты */
test {
    useJUnitPlatform() 
    include '**/*Test.class', '**/*Integration.class'
}
tasks.register('testAll') {
    group = 'verification'
    dependsOn 'build'
}

/* xml ─ валидация всех XML‑файлов */
tasks.register('xml') {
    group       = 'verification'
    description = 'Проверка корректности всех XML‑файлов (well‑formedness)'

    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()

        fileTree(projectDir) {
            include '**/*.xml'
        }.each { File xml ->
            try {
                parser.parse(xml)          // если файл некорректен → SAXException
                logger.lifecycle("✔  ${xml}")
            } catch (Exception e) {
                throw new GradleException("⛔  Invalid XML: ${xml}", e)
            }
        }
    }
}

// TODO:
/* scp ─ деплой артефакта по SSH/SCP */
remotes {
    target {
        host = param['deploy.host']
        port = (param['deploy.port'] ?: '22') as int
        user = param['deploy.user']
        password = param['deploy.password']      // ← пароль вместо identity
    }
}
ssh.settings { knownHosts = allowAnyHosts }
tasks.register('scp') {
    group = 'deployment'
    dependsOn 'build'
    description = 'Копирует скомпилированный JAR на удалённый сервер по SCP'

    doLast {
        def jarFile = tasks.bootJar.archiveFile.get().asFile
        ssh.run {
            session(remotes.target) {
                put from: jarFile, into: param['deploy.path']
            }
        }
        logger.lifecycle("✔  ${jarFile.name} uploaded to ${param['deploy.host']}:${param['deploy.path']}")
    }
}

/* ───────── native2ascii ───────── */
tasks.register('native2ascii') {
    group       = 'i18n'
    description = 'Конвертирует *.utf8.properties в ASCII-escaped *.properties'

    def srcDir = file('src/main/resources/i18n')
    def dstDir = file("$buildDir/native2ascii")

    inputs.dir  srcDir
    outputs.dir dstDir

    doLast {
        ant.native2ascii(
                encoding : 'UTF-8',
                src      : srcDir,
                dest     : dstDir,
                includes : '**/*.utf8.properties',
                ext      : '.properties'          // новое расширение
        )
    }
}

/* ───────── подключаем ASCII-ресурсы в сборку ───────── */
tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn 'native2ascii'
    from("$buildDir/native2ascii") {
        into 'i18n'                // путь в JAR'е
    }
}

/* doc */
def digest(File f, String alg) {
    MessageDigest md = MessageDigest.getInstance(alg)
    f.withInputStream { i -> byte[] buf=new byte[8192]; for(int n;(n=i.read(buf))>0;) md.update(buf,0,n) }
    md.digest().encodeHex().toString()
}

/* ─── приглушаем Javadoc-warnings ─── */
tasks.withType(Javadoc).configureEach {
    options.addBooleanOption('Xdoclint:none', true)   // JDK-8+
    failOnError = false
}

task javadocJar(type: Jar) {
    dependsOn javadoc
    archiveClassifier = 'javadoc'
    from javadoc.destinationDir
}

tasks.register('doc') {
    group       = 'documentation'
    description = 'Embed Javadoc + write MD5/SHA-1 into MANIFEST'

    dependsOn 'build', 'javadocJar'

    doLast {
        File mainJar  = tasks.bootJar.archiveFile.get().asFile

        /* 1) добавляем Javadoc-html в docs/ */
        ant.zip(update:true, destfile: mainJar) {
            zipfileset(dir: tasks.javadoc.destinationDir, prefix:'docs')
        }

        /* 2) формируем временный MANIFEST.MF с контрольными суммами */
        File tmpManifest = file("$buildDir/tmp/hash.MF")
        tmpManifest.parentFile.mkdirs()
        tmpManifest.text = """
            Manifest-Version: 1.0
            MD5: ${digest(mainJar, 'MD5')}
            SHA-1: ${digest(mainJar, 'SHA-1')}
            """.trim() + "\n"

        /* 3) «допаковываем» JAR, подменяя манифест */
        ant.jar(update:true, destfile: mainJar, manifest: tmpManifest)

        logger.lifecycle("✔  doc: Javadoc embedded, hashes written to MANIFEST")
    }
}

/* music ─ короткий «beep» по окончании сборки */
import org.gradle.internal.os.OperatingSystem

tasks.register('music') {
    group       = 'notification'
    description = 'Сборка + воспроизведение звукового сигнала'
    dependsOn   'build'

    doLast {
        def soundPath = param['music.file'] ?: ''
        def os        = OperatingSystem.current()

        /* helper: запускаем внешнюю команду, но не валим билд */
        def tryPlay = { List cmd ->
            try { exec { commandLine cmd } }
            catch(Exception ignored) { return false }
            return true
        }

        boolean played = false
        if (soundPath && file(soundPath).exists()) {
            if (os.isMacOsX())        played = tryPlay(['afplay', soundPath])
            else if (os.isLinux())    played = tryPlay(['paplay', soundPath])   // PulseAudio / PipeWire
            else if (os.isWindows())  played = tryPlay(['powershell', '-c',
                    "(New-Object Media.SoundPlayer '${file(soundPath).absolutePath}').PlaySync();"])
        }

        if (!played) print '\u0007'   // fallback BEEP
        logger.lifecycle('♪  music: done')
    }
}

/* ─── env ─── */
tasks.register("env") {
    group       = "execution"
    description = "Сборка и запуск приложения в альтернативных JVM"
    dependsOn   "classes"

    doLast {
        def profiles = (param["env.list"] ?: "")
                       .split(",")
                       .findAll { it }

        if (profiles.empty) {
            logger.lifecycle("env.list пуст — запусков не будет")
            return
        }

        File jar = tasks.bootJar.archiveFile.get().asFile

        profiles.each { p ->
            int  jdk   = (param["env.${p}.java"]   ?: "17") as int
            def  vargs = (param["env.${p}.vmArgs"] ?: "")
                         .split(" ")
                         .findAll { it }

            def launcher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(jdk)
            }.get()

            println "\n=== ENV: ${p} — JDK ${jdk} (${launcher.metadata.installationPath}) ==="
            println "VM args: ${vargs.join(' ')}"

            /* формируем полную команду: java <vmArgs> -jar <app.jar> */
            def cp = sourceSets.main.runtimeClasspath.files
                      .collect { it.absolutePath }
                      .join(File.pathSeparator)

            def cmd = [ launcher.executablePath.toString() ] +
                      vargs +
                      ["-cp", cp, MAIN_CLASS]

            exec { commandLine cmd }
        }
    }
}

/* team ─ строим 4 предыдущих ревизии и пакуем в zip */
tasks.register('team'){
    group='ci'
    doLast{
        def tmp=file("$buildDir/team"); tmp.mkdirs()
        "git rev-list --skip=1 --max-count=4 HEAD".execute().text.readLines().each{ sha->
            println "Building $sha"; ["git","checkout",sha].execute().waitFor()
            ["./gradlew","-q","build"].execute().waitFor()
            copy{
                from 'build/libs'; include '*.jar'; into tmp
                rename{n-> n.replace('.jar',"-${sha.take(7)}.jar")}
            }
        }
        ["git","checkout","HEAD"].execute().waitFor()
        ant.zip(destfile:"$buildDir/team/team_builds.zip",basedir:tmp)
    }
}


// TODO:
/* alt ─ альтернативная версия с заменами из alt.properties */

import org.gradle.api.tasks.Exec
import org.gradle.process.ExecSpec
import java.util.regex.Pattern          //  ⬅ для Pattern.quote(...)
import org.gradle.api.Action            //  ⬅ для new Action<ExecSpec>() { … }

tasks.register("alt") { task ->
    group       = "build"
    description = "Альтернативная сборка с заменами из alt.properties"
    dependsOn   "build"                        // базовый билд сначала

    doLast {
        /* ---------- 0.  читаем правила ---------- */
        def rules = new Properties()
        file("$rootDir/gradle/alt.properties").withInputStream(rules.&load)

        if (rules.isEmpty()) {
            logger.lifecycle("⚠  alt.properties пуст – задача пропущена")
            return
        }

        /* ---------- 1.  клонируем проект ---------- */
        def work = file("$buildDir/alt-work")
        work.deleteDir()
        copy {
            from '.'; into work
            exclude '.gradle', 'build', '**/alt-work/**', '**/alt/**'
        }

        /* ---------- 2.  безопасные regex-замены ---------- */
        rules.each { oldTxt, newTxt ->
            /* \b<идентификатор>\b  (Pattern.quote → экранирует спецсимволы) */
            String pattern = "\\b${Pattern.quote(oldTxt)}\\b"
            ant.replaceregexp(match: pattern,
                              replace: newTxt,
                              flags:  'g') {
                fileset(dir: "$work/src", includes: '**/*.java')
            }
        }

        /* ---------- 3.  gradlew build в worktree ---------- */
        project.exec { ExecSpec s ->   // современный DSL-вариант
            s.workingDir = work
            s.commandLine "./gradlew", "--no-daemon", "-q", "bootJar"
        }

        /* ---------- 4.  копируем JARы наружу ---------- */
        def outDir = file("$buildDir/alt")
        outDir.mkdirs()
        copy {
            from new File(work, "build/libs")
            include '*.jar'
            into  outDir
            rename { it.replace('.jar', '-alt.jar') }
        }
        work.deleteDir()

        logger.lifecycle("✔  alt-jar создан: ${outDir.list().join(', ')}")
    }
}

// ----------------------------------------------------------
// ALT-build:  читаем правила, копируем src/, делаем замену,
//             компилируем и упаковываем JAR с classifier alt
// ----------------------------------------------------------

// 1) загружаем пары old=new из gradle/alt.properties
// def replacePatterns = new LinkedHashMap<String,String>()
// def altProps = file("$rootDir/gradle/alt.properties")
// if (altProps.exists()) {
//     altProps.withReader('UTF-8') { r ->
//         r.eachLine { ln ->
//             ln = ln.trim()
//             if (ln && !ln.startsWith('#') && ln.contains('=')) {
//                 def (k, v) = ln.split('=', 2)
//                 replacePatterns[k.trim()] = v.trim()
//             }
//         }
//     }
// }
//
// tasks.register('prepareAlt') {
//     group       = 'build'
//     description = 'Копирует src в alt-sources и выполняет подстановки'
//     outputs.dir "$buildDir/alt-sources"
//
//     doLast {
//         def altSrc = file("$buildDir/alt-sources")
//         delete altSrc
//         copy {
//             from 'src/main/java'
//             into altSrc
//         }
//         replacePatterns.each { oldTok, newTok ->
//             ant.replace(dir: altSrc,
//                         token: oldTok,
//                         value: newTok,
//                         includes: '**/*.java')
//         }
//         logger.lifecycle("✔  alt-sources готовы: ${replacePatterns.size()} замены")
//     }
// }
//
// tasks.register('compileAlt', JavaCompile) {
//     dependsOn      'prepareAlt'
//     source         = fileTree("$buildDir/alt-sources") { include '**/*.java' }
//     classpath      = sourceSets.main.compileClasspath          // то же, что и main
//     destinationDir = file("$buildDir/alt-classes")
//     options.encoding = project.findProperty('encoding') ?: 'UTF-8'
//     // чтобы работал Lombok и прочие APT:
//     options.annotationProcessorPath = configurations.annotationProcessor
//     sourceCompatibility = targetCompatibility = JavaVersion.current().toString()
// }
//
// tasks.register('altJar', Jar) {
//     dependsOn 'compileAlt'
//     archiveClassifier.set('alt')
//     from "$buildDir/alt-classes"
//     manifest = tasks.bootJar.manifest               // тот же MANIFEST, что и у bootJar
// }
//
// tasks.register('alt') {
//     group       = 'build'
//     description = 'Собирает альтернативный JAR с заменёнными идентификаторами'
//     dependsOn   'altJar'
// }

/* report ─ фиксируем XML‑отчёты тестов в git */
import org.gradle.process.ExecOperations

tasks.register('report') {
    group       = 'ci'
    description = 'Копирует JUnit-XML-отчёты и коммитит их в git'
    mustRunAfter 'test'

    onlyIf {
        def testTask = tasks.named('test').get()
        return testTask.state.failure == null
    }

    doLast {
        /* -------- 1. ищем отчёты -------- */
        def srcDir = file("$buildDir/test-results/test")
        def dstDir = file("ci-reports/junit")
        def xmlSet = fileTree(srcDir) { include '**/*.xml' }

        if (xmlSet.empty) {
            logger.lifecycle('⚠  Нет JUnit-отчётов – commit пропущен')
            return
        }

        /* -------- 2. копируем наружу -------- */
        copy {
            from xmlSet
            into dstDir
        }

        def filesToCommit = fileTree(dstDir) { include '**/*.xml' }.files
        def execOps       = services.get(ExecOperations)

        /* -------- 3. git add / commit -------- */
        execOps.exec { it.commandLine 'git', 'add', '--force', *filesToCommit*.absolutePath }
        execOps.exec {
            it.commandLine 'git', 'commit',
                           '-m', "JUnit-report ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
            it.ignoreExitValue = true          // commit может вернуть 1, если изменений нет
        }

        logger.lifecycle("✔  report: закоммичено ${filesToCommit.size()} файл(ов)")
    }
}

/* автоматически вызываем report после test */
tasks.named('test') { finalizedBy 'report' }

/* diff ─ авто‑commit в SVN, если затронуты «разрешённые» файлы */
import org.gradle.process.ExecOperations

tasks.register('diff') {
    group       = 'vcs'
    description = 'Автокоммит разрешённых изменений в git'

    doLast {
        /* 1. читаем git.ignore из gradle/params.properties */
        def ignores = (param['git.ignore'] ?: '')
                      .split(',')
                      .collect { it.trim() }
                      .findAll { it }

        /* 2. получаем список изменённых файлов */
        def changed = 'git status --porcelain'
                      .execute().text.readLines()
                      .collect { it.substring(3) }          // убираем «XY␠»

        if (changed.empty) {
            logger.lifecycle('✓ diff: нет изменений – commit пропущен')
            return
        }

        /* 3. фильтруем файлы по ignore-списку */
        def allowed = changed.findAll { p ->
            ignores.every { !p.startsWith(it) }
        }
        if (allowed.empty) {
            logger.lifecycle('⚠ diff: все изменения попали под git.ignore')
            return
        }

        /* 4. делим на существующие и удалённые */
        def existing = allowed.findAll { file(it).exists() }
        def deleted  = allowed - existing
        def ex       = services.get(ExecOperations)

        if (!existing.empty) {
            ex.exec {
                commandLine 'git', 'add', *existing
                ignoreExitValue = true
            }
        }
        if (!deleted.empty) {
            ex.exec {
                commandLine 'git', 'add', '-u', *deleted
                ignoreExitValue = true
            }
        }

        /* 5. commit (возвращает 1, если нечего фиксировать) */
        ex.exec {
            def ts = new Date().format('yyyy-MM-dd HH:mm:ss')
            commandLine 'git', 'commit', '-m', "Auto commit ${ts}"
            ignoreExitValue = true
        }
    }
}
// TODO:
/* history ─ ищем последнюю рабочую ревизию, выводим diff */
