import java.security.MessageDigest
import org.hidetake.groovy.ssh.session.SessionHandler
import javax.xml.parsers.DocumentBuilderFactory

plugins {
    id 'java'
    id 'application'
    id 'org.springframework.boot' version '3.3.5'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'org.hidetake.ssh' version '2.10.1'
}

group   = 'org.awesoma'
version = '0.0.1-SNAPSHOT'

def MAIN_CLASS = 'org.awesoma.back.BackApplication'

application { mainClass = MAIN_CLASS }

java.toolchain.languageVersion = JavaLanguageVersion.of(17)
repositories      { mavenCentral() }
dependencies      { 
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'


    implementation 'io.jsonwebtoken:jjwt:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'


    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

def param = new Properties()
file("$rootDir/gradle/params.properties").withInputStream(param.&load)

tasks.withType(Jar).configureEach {
    manifest.attributes(
        'Main-Class'           : MAIN_CLASS,
        'Implementation-Version': version
    )
}


/* compile */
tasks.register('compile') {
    group = 'build'; description = 'Compiles project sources'
    dependsOn 'classes'
}

/* build */
tasks.named('build') { dependsOn 'compile' }

/* clean */

/* test */
test {
    useJUnitPlatform() 
    include '**/*Test.class', '**/*Integration.class'
}
tasks.register('testAll') {
    group = 'verification'
    dependsOn 'build'
}

/* xml */
tasks.register('xml') {
    group       = 'verification'
    description = 'Проверка корректности всех XML‑файлов (well‑formedness)'

    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()

        fileTree(projectDir) {
            include '**/*.xml'
        }.each { File xml ->
            try {
                parser.parse(xml)      
                logger.lifecycle("✔  ${xml}")
            } catch (Exception e) {
                throw new GradleException("⛔  Invalid XML: ${xml}", e)
            }
        }
    }
}

/* scp  */
import org.gradle.api.tasks.Exec

def scpHost       = param['deploy.host']       ?: 'example.com'
def scpUser       = param['deploy.user']       ?: 'user'
def scpRemotePath = param['deploy.path']       ?: '~/apps/'
def scpKeyFile    = param['deploy.keyFile']?.trim()

def artefact = tasks.named('bootJar')

tasks.register('scp', Exec) {
    group       = 'deployment'
    description = 'Собирает проект и копирует boot JAR на удалённый сервер по scp'
    dependsOn   artefact

    doFirst {
        def cmd = ['scp']
        if (scpKeyFile) {
            cmd += ['-i', scpKeyFile]
        }
        cmd += [
            artefact.get().archiveFile.get().asFile.absolutePath,
            "${scpUser}@${scpHost}:${scpRemotePath}"
        ]
        commandLine cmd
        println "▶ scp: ${cmd.join(' ')}"
    }

    ignoreExitValue = false
}

/* ───────── native2ascii ───────── */
tasks.register('native2ascii') {
    group       = 'i18n'
    description = 'Конвертирует *.utf8.properties в ASCII-escaped *.properties'

    def srcDir = file('src/main/resources/i18n')
    def dstDir = file("$buildDir/native2ascii")

    inputs.dir  srcDir
    outputs.dir dstDir

    doLast {
        ant.native2ascii(
                encoding : 'UTF-8',
                src      : srcDir,
                dest     : dstDir,
                includes : '**/*.utf8.properties',
                ext      : '.properties'
        )
    }
}

/* ───────── подключаем ASCII-ресурсы в сборку ───────── */
tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn 'native2ascii'
    from("$buildDir/native2ascii") {
        into 'i18n'
    }
}

/* doc */
def digest(File f, String alg) {
    MessageDigest md = MessageDigest.getInstance(alg)
    f.withInputStream { i -> byte[] buf=new byte[8192]; for(int n;(n=i.read(buf))>0;) md.update(buf,0,n) }
    md.digest().encodeHex().toString()
}

tasks.withType(Javadoc).configureEach {
    options.addBooleanOption('Xdoclint:none', true)
    failOnError = false
}

task javadocJar(type: Jar) {
    dependsOn javadoc
    archiveClassifier = 'javadoc'
    from javadoc.destinationDir
}

tasks.register('doc') {
    group       = 'documentation'
    description = 'Embed Javadoc + write MD5/SHA-1 into MANIFEST'

    dependsOn 'build', 'javadocJar'

    doLast {
        File mainJar  = tasks.bootJar.archiveFile.get().asFile

        ant.zip(update:true, destfile: mainJar) {
            zipfileset(dir: tasks.javadoc.destinationDir, prefix:'docs')
        }

        File tmpManifest = file("$buildDir/tmp/hash.MF")
        tmpManifest.parentFile.mkdirs()
        tmpManifest.text = """
            Manifest-Version: 1.0
            MD5: ${digest(mainJar, 'MD5')}
            SHA-1: ${digest(mainJar, 'SHA-1')}
            """.trim() + "\n"

        ant.jar(update:true, destfile: mainJar, manifest: tmpManifest)

        logger.lifecycle("✔  doc: Javadoc embedded, hashes written to MANIFEST")
    }
}

/* music  */
import org.gradle.internal.os.OperatingSystem

tasks.register('music') {
    group       = 'notification'
    description = 'Сборка + воспроизведение звукового сигнала'
    dependsOn   'build'

    doLast {
        def soundPath = param['music.file'] ?: ''
        def os        = OperatingSystem.current()

        def tryPlay = { List cmd ->
            try { exec { commandLine cmd } }
            catch(Exception ignored) { return false }
            return true
        }

        boolean played = false
        if (soundPath && file(soundPath).exists()) {
            if (os.isMacOsX())        played = tryPlay(['afplay', soundPath])
            else if (os.isLinux())    played = tryPlay(['paplay', soundPath])
            else if (os.isWindows())  played = tryPlay(['powershell', '-c',
                    "(New-Object Media.SoundPlayer '${file(soundPath).absolutePath}').PlaySync();"])
        }

        if (!played) print '\u0007'   // fallback BEEP
        logger.lifecycle('♪  music: done')
    }
}

/* ─── env ─── */
tasks.register("env") {
    group       = "execution"
    description = "Сборка и запуск приложения в альтернативных JVM"
    dependsOn   "classes"

    doLast {
        def profiles = (param["env.list"] ?: "")
                       .split(",")
                       .findAll { it }

        if (profiles.empty) {
            logger.lifecycle("env.list пуст — запусков не будет")
            return
        }

        File jar = tasks.bootJar.archiveFile.get().asFile

        profiles.each { p ->
            int  jdk   = (param["env.${p}.java"]   ?: "17") as int
            def  vargs = (param["env.${p}.vmArgs"] ?: "")
                         .split(" ")
                         .findAll { it }

            def launcher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(jdk)
            }.get()

            println "\n=== ENV: ${p} — JDK ${jdk} (${launcher.metadata.installationPath}) ==="
            println "VM args: ${vargs.join(' ')}"

            def cp = sourceSets.main.runtimeClasspath.files
                      .collect { it.absolutePath }
                      .join(File.pathSeparator)

            def cmd = [ launcher.executablePath.toString() ] +
                      vargs +
                      ["-cp", cp, MAIN_CLASS]

            exec { commandLine cmd }
        }
    }
}

/* team */
tasks.register('team'){
    group='ci'
    doLast{
        def tmp=file("$buildDir/team"); tmp.mkdirs()
        "git rev-list --skip=1 --max-count=4 HEAD".execute().text.readLines().each{ sha->
            println "Building $sha"; ["git","checkout",sha].execute().waitFor()
            ["./gradlew","-q","build"].execute().waitFor()
            copy{
                from 'build/libs'; include '*.jar'; into tmp
                rename{n-> n.replace('.jar',"-${sha.take(7)}.jar")}
            }
        }
        ["git","checkout","HEAD"].execute().waitFor()
        ant.zip(destfile:"$buildDir/team/team_builds.zip",basedir:tmp)
    }
}


/* alt */
import org.gradle.api.tasks.Exec
import org.gradle.process.ExecSpec
import java.util.regex.Pattern
import org.gradle.api.Action

tasks.register("alt") { task ->
    group       = "build"
    description = "Альтернативная сборка с заменами из alt.properties"
    dependsOn   "build"

    doLast {
        def rules = new Properties()
        file("$rootDir/gradle/alt.properties").withInputStream(rules.&load)

        if (rules.isEmpty()) {
            logger.lifecycle("⚠  alt.properties пуст – задача пропущена")
            return
        }

        def work = file("$buildDir/alt-work")
        work.deleteDir()
        copy {
            from '.'; into work
            exclude '.gradle', 'build', '**/alt-work/**', '**/alt/**'
        }

        rules.each { oldTxt, newTxt ->
            String pattern = "\\b${Pattern.quote(oldTxt)}\\b"
            ant.replaceregexp(match: pattern,
                              replace: newTxt,
                              flags:  'g') {
                fileset(dir: "$work/src", includes: '**/*.java')
            }
        }

        project.exec { ExecSpec s ->
            s.workingDir = work
            s.commandLine "./gradlew", "--no-daemon", "-q", "bootJar"
        }

        def outDir = file("$buildDir/alt")
        outDir.mkdirs()
        copy {
            from new File(work, "build/libs")
            include '*.jar'
            into  outDir
            rename { it.replace('.jar', '-alt.jar') }
        }
        work.deleteDir()

        logger.lifecycle("✔  alt-jar создан: ${outDir.list().join(', ')}")
    }
}

/* report */
import org.gradle.process.ExecOperations

tasks.register('report') {
    group       = 'ci'
    description = 'Копирует JUnit-XML-отчёты и коммитит их в git'
    mustRunAfter 'test'

    onlyIf {
        def testTask = tasks.named('test').get()
        return testTask.state.failure == null
    }

    doLast {
        def srcDir = file("$buildDir/test-results/test")
        def dstDir = file("ci-reports/junit")
        def xmlSet = fileTree(srcDir) { include '**/*.xml' }

        if (xmlSet.empty) {
            logger.lifecycle('⚠  Нет JUnit-отчётов – commit пропущен')
            return
        }

        copy {
            from xmlSet
            into dstDir
        }

        def filesToCommit = fileTree(dstDir) { include '**/*.xml' }.files
        def execOps       = services.get(ExecOperations)

        execOps.exec { it.commandLine 'git', 'add', '--force', *filesToCommit*.absolutePath }
        execOps.exec {
            it.commandLine 'git', 'commit',
                           '-m', "JUnit-report ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
            it.ignoreExitValue = true          // commit может вернуть 1, если изменений нет
        }

        logger.lifecycle("✔  report: закоммичено ${filesToCommit.size()} файл(ов)")
    }
}

/* автоматически вызываем report после test */
tasks.named('test') { finalizedBy 'report' }

/* diff  */
import org.gradle.process.ExecOperations

tasks.register('diff') {
    group       = 'vcs'
    description = 'Автокоммит разрешённых изменений в git'

    doLast {
        def ignores = (param['git.ignore'] ?: '')
                      .split(',')
                      .collect { it.trim() }
                      .findAll { it }

        def changed = 'git status --porcelain'
                      .execute().text.readLines()
                      .collect { it.substring(3) }

        if (changed.empty) {
            logger.lifecycle('✓ diff: нет изменений – commit пропущен')
            return
        }

        def allowed = changed.findAll { p ->
            ignores.every { !p.startsWith(it) }
        }
        if (allowed.empty) {
            logger.lifecycle('⚠ diff: все изменения попали под git.ignore')
            return
        }

        def existing = allowed.findAll { file(it).exists() }
        def deleted  = allowed - existing
        def ex       = services.get(ExecOperations)

        if (!existing.empty) {
            ex.exec {
                commandLine 'git', 'add', *existing
                ignoreExitValue = true
            }
        }
        if (!deleted.empty) {
            ex.exec {
                commandLine 'git', 'add', '-u', *deleted
                ignoreExitValue = true
            }
        }

        ex.exec {
            def ts = new Date().format('yyyy-MM-dd HH:mm:ss')
            commandLine 'git', 'commit', '-m', "Auto commit ${ts}"
            ignoreExitValue = true
        }
    }
}

