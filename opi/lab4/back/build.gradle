/* ────────────────────────────  back/build.gradle  ──────────────────────────── */
import java.security.MessageDigest
import org.hidetake.groovy.ssh.session.SessionHandler          // плагин scp/ssh
import javax.xml.parsers.DocumentBuilderFactory

/***************************  ПЛАГИНЫ  *****************************************/
plugins {
    id 'java'
    id 'application'
    id 'org.springframework.boot' version '3.3.5'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'org.hidetake.ssh' version '2.10.1'             // «scp»‑цель
}

/***************************  ОБЩИЕ НАСТРОЙКИ  *********************************/
group   = 'org.awesoma'
version = '0.0.1-SNAPSHOT'

def MAIN_CLASS = 'org.awesoma.back.BackApplication'

application { mainClass = MAIN_CLASS }

java.toolchain.languageVersion = JavaLanguageVersion.of(17)
repositories      { mavenCentral() }
dependencies      { 
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-web-services'
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'


    implementation 'io.jsonwebtoken:jjwt:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'


    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

/***************************  ПАРАМЕТРЫ ИЗ ФАЙЛА  *******************************/
def param = new Properties()
file("$rootDir/gradle/params.properties").withInputStream(param.&load)

/***************************  MANIFEST  *****************************************/
tasks.withType(Jar).configureEach {
    manifest.attributes(
        'Main-Class'           : MAIN_CLASS,
        'Implementation-Version': version
    )
}


/* compile */
tasks.register('compile') {
    group = 'build'; description = 'Compiles project sources'
    dependsOn 'classes'
}

/* build ─ всё как обычно, но явно зависит от compile */
tasks.named('build') { dependsOn 'compile' }

/* clean ─ стандартный, ничего менять не нужно */

/* test ─ сначала build, затем юнит‑тесты */
test {
    useJUnitPlatform() 
    include '**/*Test.class', '**/*Integration.class'
}
tasks.register('testAll') {
    group = 'verification'
    dependsOn 'build'
}

/* xml ─ валидация всех XML‑файлов */
tasks.register('xml') {
    group       = 'verification'
    description = 'Проверка корректности всех XML‑файлов (well‑formedness)'

    doLast {
        def parser = DocumentBuilderFactory.newInstance().newDocumentBuilder()

        fileTree(projectDir) {
            include '**/*.xml'
        }.each { File xml ->
            try {
                parser.parse(xml)          // если файл некорректен → SAXException
                logger.lifecycle("✔  ${xml}")
            } catch (Exception e) {
                throw new GradleException("⛔  Invalid XML: ${xml}", e)
            }
        }
    }
}

// TODO:
/* scp ─ деплой артефакта по SSH/SCP */
remotes {
    target {
        host = param['deploy.host']
        port = (param['deploy.port'] ?: '22') as int
        user = param['deploy.user']
        password = param['deploy.password']      // ← пароль вместо identity
    }
}
ssh.settings { knownHosts = allowAnyHosts }
tasks.register('scp') {
    group = 'deployment'
    dependsOn 'build'
    description = 'Копирует скомпилированный JAR на удалённый сервер по SCP'

    doLast {
        def jarFile = tasks.bootJar.archiveFile.get().asFile
        ssh.run {
            session(remotes.target) {
                put from: jarFile, into: param['deploy.path']
            }
        }
        logger.lifecycle("✔  ${jarFile.name} uploaded to ${param['deploy.host']}:${param['deploy.path']}")
    }
}

/* ───────── native2ascii ───────── */
tasks.register('native2ascii') {
    group       = 'i18n'
    description = 'Конвертирует *.utf8.properties в ASCII-escaped *.properties'

    def srcDir = file('src/main/resources/i18n')
    def dstDir = file("$buildDir/native2ascii")

    inputs.dir  srcDir
    outputs.dir dstDir

    doLast {
        ant.native2ascii(
                encoding : 'UTF-8',
                src      : srcDir,
                dest     : dstDir,
                includes : '**/*.utf8.properties',
                ext      : '.properties'          // новое расширение
        )
    }
}

/* ───────── подключаем ASCII-ресурсы в сборку ───────── */
tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn 'native2ascii'
    from("$buildDir/native2ascii") {
        into 'i18n'                // путь в JAR'е
    }
}

/* doc */
def digest(File f, String alg) {
    MessageDigest md = MessageDigest.getInstance(alg)
    f.withInputStream { i -> byte[] buf=new byte[8192]; for(int n;(n=i.read(buf))>0;) md.update(buf,0,n) }
    md.digest().encodeHex().toString()
}

/* ─── приглушаем Javadoc-warnings ─── */
tasks.withType(Javadoc).configureEach {
    options.addBooleanOption('Xdoclint:none', true)   // JDK-8+
    failOnError = false
}

task javadocJar(type: Jar) {
    dependsOn javadoc
    archiveClassifier = 'javadoc'
    from javadoc.destinationDir
}

tasks.register('doc') {
    group       = 'documentation'
    description = 'Embed Javadoc + write MD5/SHA-1 into MANIFEST'

    dependsOn 'build', 'javadocJar'

    doLast {
        File mainJar  = tasks.bootJar.archiveFile.get().asFile

        /* 1) добавляем Javadoc-html в docs/ */
        ant.zip(update:true, destfile: mainJar) {
            zipfileset(dir: tasks.javadoc.destinationDir, prefix:'docs')
        }

        /* 2) формируем временный MANIFEST.MF с контрольными суммами */
        File tmpManifest = file("$buildDir/tmp/hash.MF")
        tmpManifest.parentFile.mkdirs()
        tmpManifest.text = """
            Manifest-Version: 1.0
            MD5: ${digest(mainJar, 'MD5')}
            SHA-1: ${digest(mainJar, 'SHA-1')}
            """.trim() + "\n"

        /* 3) «допаковываем» JAR, подменяя манифест */
        ant.jar(update:true, destfile: mainJar, manifest: tmpManifest)

        logger.lifecycle("✔  doc: Javadoc embedded, hashes written to MANIFEST")
    }
}

// TODO:
/* music ─ короткий «beep» по окончании сборки */
tasks.register('music'){ dependsOn 'build'; doLast{ print '\u0007' }}

// TODO:
/* env ─ сборка и запуск в альтернативных окружениях */
(param['env.list']?:'').split(',').findAll{it}.each{ name->
    tasks.register("env_${name}"){
        group='execution'; dependsOn 'build'
        doLast{
            javaexec{
                executable=javaToolchains.launcherFor{
                    languageVersion=JavaLanguageVersion.of(param["env.${name}.java"] as int)
                }.get().executablePath
                classpath=sourceSets.main.runtimeClasspath
                mainClass.set(MAIN_CLASS)
                jvmArgs (param["env.${name}.vmArgs"]?:'').split(' ').findAll{it}
            }
        }
    }
}

// TODO:
/* team ─ строим 4 предыдущих ревизии и пакуем в zip */
tasks.register('team'){
    group='ci'
    doLast{
        def tmp=file("$buildDir/team"); tmp.mkdirs()
        "git rev-list --skip=1 --max-count=4 HEAD".execute().text.readLines().each{ sha->
            println "Building $sha"; ["git","checkout",sha].execute().waitFor()
            ["./gradlew","-q","build"].execute().waitFor()
            copy{
                from 'build/libs'; include '*.jar'; into tmp
                rename{n-> n.replace('.jar',"-${sha.take(7)}.jar")}
            }
        }
        ["git","checkout","HEAD"].execute().waitFor()
        ant.zip(destfile:"$buildDir/team/team_builds.zip",basedir:tmp)
    }
}

// TODO:
/* alt ─ альтернативная версия с заменами из alt.properties */
tasks.register('alt'){
    group='build'; dependsOn 'build'
    doLast{
        def altDir=file("$buildDir/alt/src"); copy{from 'src'; into altDir}
        def rep=new Properties(); file("$rootDir/gradle/alt.properties").withInputStream(rep.&load)
        rep.each{k,v-> ant.replaceregexp(match:k,replace:v,flags:'g'){ fileset(dir:altDir,includes:'**/*.java')}}
        ant.javac(srcdir:altDir,destdir:"$buildDir/alt/classes",includeAntRuntime:false,source:'17',target:'17')
        ant.jar(destfile:"$buildDir/alt/${project.name}-alt.jar",basedir:"$buildDir/alt/classes",manifest:jar.manifest.attributes)
    }
}

// TODO:
/* report ─ фиксируем XML‑отчёты тестов в git */
tasks.register('report'){
    mustRunAfter 'test'; group='ci'
    onlyIf{ tasks.test.state.failure==null }
    doLast{
        def reports=fileTree("$buildDir/test-results/test"){ include '**/*.xml'}
        reports.each{ exec{ commandLine 'git','add',it }}
        if(!reports.isEmpty()) exec{ commandLine 'git','commit','-m',"JUnit‑report ${new Date().format('yyyy‑MM‑dd HH:mm:ss')}" }
    }
}

// TODO:
/* diff ─ авто‑commit в SVN, если затронуты «разрешённые» файлы */
tasks.register('diff'){
    group='vcs'
    doLast{
        def ign=(param['svn.ignore']?:'').split(',')*.trim()
        def status="svn status".execute().text.readLines()
        def toCommit=status.findAll{ l-> ign.every{!l.substring(8).startsWith(it)} }
        if(toCommit){ exec{ commandLine 'svn','commit','-m','Auto commit',*toCommit.collect{it.substring(8)}} }
    }
}

// TODO:
/* history ─ ищем последнюю рабочую ревизию, выводим diff */
tasks.register('history'){
    group='ci'
    doLast{
        def revs="git rev-list --reverse HEAD".execute().text.readLines()
        String ok
        for(sha in revs){
            ["git","checkout",sha].execute().waitFor()
            if(["./gradlew","-q","classes"].execute().waitFor()==0){ ok=sha; break }
        }
        if(ok){
            def next="git rev-list --ancestry-path ${ok}..HEAD | tail -1".execute().text.trim()
            if(next){
                def diff="git diff ${ok}..${next}".execute().text
                file("$buildDir/history_diff.txt").text=diff
                println 'History diff saved to build/history_diff.txt'
            }
        }
        ["git","checkout","HEAD"].execute().waitFor()
    }
}
